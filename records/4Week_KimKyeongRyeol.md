## Title: [4Week] 김경렬

### 미션 요구사항 분석 & 체크리스트

---

- [x] 내가 받은 호감리스트 성별/호감사유 필터링 기능 구현
  ##### [요구사항]
  1. 내가 받은 호감리스트를 옵션에 따라 필터링을 하여 보여준다.
  2. 옵션은 2가지이다. 
     1. `성별`
     2. `호감사유`

<br><br>

- [x] 내가 받은 호감리스트 정렬 기능 구현
  ##### [요구사항]
  1. 호감리스트를 보여줄 때, 옵션에 따라 정렬을 하여 보여준다.
  2. 옵션은 6가지이다.
     1. `최신순` &rarr; 가장 최근에 받은 호감표시를 우선적으로 표시
     2. `날짜순` &rarr; 가장 오래전에 받은 호감표시를 우선적으로 표시
     3. `인기 많은 순` &rarr; 가장 인기가 많은 사람들의 호감표시를 우선적으로 표시
     4. `인기 적은 순` &rarr; 가장 인기가 적은 사람들의 호감표시를 우선적으로 표시
     5. `성별순` &rarr; 여성에게 받은 호감표시를 먼저 표시하고, 그 다음 남자에게 받은 호감표시를 후에 표시
     6. `호감사유순` &rarr; 외모 때문에 받은 호감표시를 먼저 표시하고, 그 다음 성격 때문에 받은 호감표시를 후에 표시, 마지막으로 능력 때문에 받은 호감표시를 후에 표시
  3. `성별순`은 같은 성별의 호감이 여러개 일 경우, 최신순으로 한번 더 정렬한다.
  4. `호감사유순`은 같은 호감사유의 호감이 여러개 일 경우, 최신순으로 한번 더 정렬한다.

<br><br>

- [x] 배포
  ##### [요구사항]
  1. `https://도메인/`형태로 접속이 가능해야 한다.
  2. 운영서버에서 각종 소셜로그인, 인스타 아이디 연결이 잘 되어야 한다.
  
### 4주차 미션 요약

---

**[접근 방법]**

## **1) 내가 받은 호감리스트 성별/호감사유 필터링 기능 구현**

### [1차 작업] : 성별 필터링 기능 구현

1. `LikeablePersonController` 클래스 안에 `showToList()`의 파라미터로 `HttpServletRequest request`를 추가하여 요청 시 넘겨받은 값들을 찾을 수 있게 한다.
2. `LikeablePersonService` 클래스에 `listing()`이라는 새로운 메소드를 정의한다. 이때, 메소드의 파라미터로 현재 로그인한 유저의 `InstaMember`와 요청 시 넘겨주었던 값들을 받는다.
3. `listing()`는 현재 로그인 한 유저가 받은 호감리스트를 반환하는 메소드다. <br>
   &rarr; 만약 `gender`가 `null`이거나 공백이라면, 성별 필터링 옵션이 없다는 것이니 호감리스트를 그대로 반환한다.<br>
   아니라면, 해당 호감을 발생시킨 유저의 성별과 `gender`가 같은 호감만 필터링 하여 반환한다.

> **문제**
> 1. `if-else`를 사용하고 있는데, 이를 사용하지 않고도 작동하는 로직을 생각해야함

### [2차 작업] : 1차 작업 문제 해결 및 호감사유 필터링 기능 구현

1. `if-else`를 삭제하고 마지막에 `return likeablePeople;`을 써준 뒤, `gender`값이 있을 경우(공백X)에만 해당 값으로 필터링한 리스트를 `likeablePeople` 변수에 넣어주도록 변경
2. 호감사유도 위와 동일한 로직으로 구현<br>
   &rarr; `attractiveTypeCode`값이 있을 경우(공백X)에만 해당 값으로 필터링한 리스트를 `likeablePeople` 변수에 넣어줌

## **2) 내가 받은 호감리스트 정렬 기능 구현**

### [1차 작업]

1. 필터링 작업이 끝난 후, 최종 반환하기 전에 정렬하는 로직을 넣어줌
2. 만약 `sortCode`가 `null`이거나 공백일 경우, 기본값인 `최신순`으로 정렬<br>
   아닌 경우, 해당 `sortCode`를 기준으로 정렬
3. 이를 위해 `Comparator` 객체가 필요함 &rarr; `Comparator<LikeablePerson>` 객체를 반환하는 `compareTo()` 메소드 생성
4. `switch`문을 사용하여 매개변수로 받은 `typeCode`를 기준으로, 경우에 맞는 `Comparator` 객체를 반환 &rarr; 잘못된 인자를 넣을 경우(default) : 최신순("1") 객체 반환

> **문제**
> 1. 정렬에서도 `if-else`를 사용하고 있는데, 이를 사용하지 않고도 작동하는 로직을 생각해야함
> 2. 현재 정렬 조건이 필터링 기능 조건과 통일된 형태가 아니여서 가독성이 낮음. 한가지 형태로 통일 할 필요성 느낌<br>
     &rarr; 현재 정렬 조건 : 값이 !없을! 경우<br>
     &rarr; 현재 필터링 조건 : 값이 !있을! 경우
> 3. `compareTo()` 메소드의 코드가 너무 길고, 가독성이 낮음

### [2차 작업] : 1차 작업 문제 해결

1. 정렬 조건을 반대로 바꿔서 문제2 해결
2. 람다식을 적용하고, 내부에서 중복된 로직들을 `compareTo()` 메소드를 재호출하는 형태로 변경하여 중복을 제거해서 문제3 해결

> **문제**
> 1. 아직도 1차 작업 문제1을 해결하지 못했음
> 2. 필터링 기능과 정렬 기능을 추가하다보니, `listing()` 메소드가 너무 커져버림. 메소드를 조금 더 잘게 나눠야할 필요성 느낌.
> 3. 다시 생각해보니 컨트롤러에서 굳이 `HttpRequest`를 추가해서, 각각의 변수를 `getParameter()`로 찾아야하나 싶은 생각이 들었음. 괜히 코드만 3줄 추가 됨.

### [3차 작업] : 2차 작업 문제 해결

1. `listing()` 메소드의 기능을 분리하기 위해 `filteringBy()` 메소드를 도입하려고 했으나, 현재 `attractiveTypeCode`와 `gender`가 같은 타입이기에 메소드 오버로딩이 불가능한 상황에 놓였다.
2. 물론 메소드명을 각각 `filteringByGender()`와 `filteringByAttractiveTypeCode`로 하여 해결할 수 있었지만, 더 유연한 사용을 위해 `filteringBy()`를 고집했다.
3. 따라서, 오버로딩을 위해서는 타입을 다르게 받아줄 필요가 있음.
4. 그래서 생각한 해결 방법으로, 현재는 컨트롤러단에서 `HttpRequest`를 이용해 `String`타입으로 값을 꺼내오는 형태지만, `HttpRequest`를 사용해서 값을 찾지말고, 애초에 파라미터로 지정해서 원하는 타입으로 받아오면 된다.<br>
   &rarr; 수정 전 : `showToList(Model model, HttpServletRequest request)` <br>
   &rarr; 수정 후 : `showToList(Model model, @RequestParam(defaultValue = "") String gender, @RequestParam(defaultValue = "0") int attractiveTypeCode, @RequestParam(defaultValue = "0") int sortCode)`
5. 이렇게 하니 공백일 경우, 원하는 타입대로 바로 받을수도 있고 기본값을 지정해주는것도 간편하게 해결되었다.
6. 이제 `listing()`의 매개변수 중에 `attractiveTypeCode`와 `sortCode`의 타입을 `int`로 변경한다.
7. 그에 따라, 기존에는 `null`과 `isBlank()`로 조건을 달아줬었지만 이제는 기본값을 설정해줬으니, 조건을 아래와 같이 변경해 줄 수 있다.<br>
   &rarr; 성별 필터링 조건 : `if(gender.equals("M") || gender.equals("W"))` <br>
   &rarr; 호감사유 필터링 조건 : `if(attractiveTypeCode > 0 && attractiveTypeCode < 4)`
8. 또한 이제 `gender`와 `attractiveTypeCode`의 타입이 다르기에 `filteringBy()`를 오버로딩할 수 있게 되었고, 메소드 기능 분리를 통해 `listing()` 메소드의 크기를 많이 줄였다.
9. 그리고 마지막으로, 이젠 `sortCode`도 기본값이 있기 때문에 정렬하는 로직 또한 `if-else`문을 제거하고, 단순 `return` 한줄만으로도 정렬이 가능해졌다!